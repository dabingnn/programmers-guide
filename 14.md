# Chapter  14: Advanced Topics

## Best Practice - Optimization, memory, performance, profiling
    
## Sound
    
## SQLite
    
## Subclass Cocos2d-x classes
    
## Data structures (i.e Vector)
    
## Custom OpenGL (what to cover here? CustomCommand?)
    
## c++11 usage
    
## rendering pipeline (notes about this in the wiki)
Since cocos2d-x 3.0, a new `renderer` was used for rendering. Instead of calling openGL function directly, now rendering function calls are encapasulated into renderCommand. RenderCommand is generated when traversing scene, and consumed by `Renderer` to do actual rendering.

The new rendering workflow could be simplied as:

```
void Director::DrawScene()
{
	//visit scene and generate rendering Command
	_runningScene->visit();
	//execute render command and draw
	_render->render();
}
```
The `visit()` function is used to generate render command and traverse the scene.

```
void Node::visit(...)
{
	//visit children zorder less than 0
	for(auto child : childen)
	{
		if(child->_zorder < 0)
			child->visit(...);
	}
	//draw self, generate rendering command and insert it into render
	draw(...)
	//visit children zorder bigger than 0
	for(auto child : childen)
	{
		if(child->_zorder > 0)
			child->visit(...);
	}
}
```
###Different type of RenderCommand
Inorde to support different type of rendering, there are several type of renderCommand. Which is used for specific type of rendering.

####TrianglesCommand and QuadCommand
TrianglesCommand and QuadCommand are two of the mostly used renderCommand. They are used for rendering Triangles and Quads. We will take sprite rendering as an example for showing the usage of these two type of commands.

To render sprite using QuadCommand, what you need to do is:

```
_quadCommand.init(_globalZOrder, textureID, glprogramState, blendFunc, &_quad, quadCount, modelviewTransform);
renderer->addCommand(&_quadCommand);
```
Or you can render sprite with TrianglesCommand

```
//generate two triangles based on quad
static GLushort indices[6] = {0,1,2,3,2,1};
auto triangles = TrianglesCommand::Triangles{&_quad.tl,indices,4,6};
trianglesCommand.(_globalZOrder, textureID, glprogramState, blendFunc, &triangles, modelviewTransform);
renderer->addCommand(&trianglesCommand);
```
When using `TrianglesCommand` and `QuadCommand`, we need to take care about of rendered data. The rendered quads or triangles are pointer in command, so if commands are generated and add to renderer, it is unsafe to delete the sprite.

####GroupCommand

RenderCommands could be sorted by _globalZOrder, command with smaller _globalZorder will be sorted to the front. However, in some situations, we want to the rendering commands to be sorted in a contrained range. 
GroupCommand is designed for this purposem, it includes two features:

* Constrain the command sorting in a range.
* Package all the constrained command into a groupCommand and sort it as a whole.

Examples to use GroupCommand:

```
//package groupCommand
groupCommand.init(_globalZOrder);
renderer->addCommand(&groupCommand);
```

```
render->pushGroup(groupCommand.getRenderQueueID());
//insert other renderCommands here.
//render->addCommand(...);

render->popGroup();
```

The first section is very simple, a groupCommand is created and insert into renderer. And the second one, two functions `pushGroup()` and `popGroup()` is used, renderCommand inserted into renderer between this functions will not be sorted outside of it.

####PrimitiveCommand
PrimitiveCommand was used to send different type of render primitives (such as Points, Lines and Triangles) to renderer. The command will behaves similar as `TrianglesCommand` and `QuadCommand`, but take a `Primitive` as its parameter.

`Primitive` is the most important part of `PrimitiveCommand`.
A Primitive will contains

* `VertexData`: how the vertex data is specified
* `PrimtiveType`: Points, Lines, Triangles
* `IndexBuffer`: optional
* `Start` and `Count`: specify a part of data to be drawn

The process of generate a primitive:

* generate VertexData and vertexBuffer:
	
	```
	auto buff = VertexBuffer::create(vertexSize, vertexCount);
	buff->updateVertices(data, start, count);
	auto vdata = VertexData::create();
	//buff may contains several stream attribute
	vdata->setStream(buff, VertexStreamAttribute(...));
	vdata->setStream(buff, VertexStreamAttribute(...));
	vdata->setStream(buff, VertexStreamAttribute(...));
	```
* generate IndexBuffer if it exsists:
	
	```
	//type could be short16 or int32
	auto iBuff = IndexBuffer::create(type, count);
	iBuff->updateIndices(data, start, count);
	```
* create `Primitive`, specify `PrimtiveType`,`Start` and `Count`
	
	```
	//specify index buffer with null if no index is needed.
	auto primitive = Primitive::create(vdata, iBuff, primitiveType);
	primitive->setStart(...);
	primitive->setCount(...);
	```

####CustomCommand
Just sending points, lines and triangles to openGL is not enough. Some other openGL function must be called to achieve special effects, such as enable or disable depth test, switch a glprogram, set a uniform to shader etc. `CustomCommand` is now used to solve this.
CustomCommand could be used like this:

```
customCommand.init(_globalZOrder);
customCommand.func = CC_CALLBACK0(...);
renderer->addCommand(&customCommand);
```

CustomCommand use callback, which will be called duing `renderer->render()`. So in order to migrate to CustomCommand from cocos2d-x 2.x version. What you need to do is to move the openGL function call into a callback, and using `CC_CALLBACK0` to bind callback to `func` member variable of `CustomCommand`.
One thing to take care is that callback is also a reference, it is not safe to delete the data before the `CustomCommand` is executed by renderer.

## Networking with HTTP

HTTP networking has three steps
   1. Create an `HttpRequest` 
   2. Create a `setResponseCallback()` callback function for replying to requests.
   3. Send `HttpRequest` by `HttpClient` 