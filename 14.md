# Chapter  14: Advanced Topics

## Best Practice - Optimization, memory, performance, profiling
    
## Sound
    
## SQLite
    
## Subclass Cocos2d-x classes
    
## Data structures (i.e Vector)
    
## Custom OpenGL Shaders
`GlProgram` and `GLProgramState` are used to manage shaders in cocos2d-x. `GLProgram` comes from the old `CCGLProgram` in 2.x version. and the newly added `GLProgramState` is used to encapsulate `shaders`, `Uniforms` and `Attributes`.
###GLProgram
`GLProgram` is an encapsulation for OpenGL Shaders, `GLProgram` is basically created by two shader sources, `Vertex Shader` source and `Fragment Shader` source. So, there are two ways to create it:

```
//create GLProgram from sources
static GLProgram* createWithByteArrays(const GLchar* vShaderByteArray, const GLchar* fShaderByteArray);
//create GLProgram from source files
static GLProgram* createWithFilenames(const std::string& vShaderFilename, const std::string& fShaderFilename);
```
**Notes**: cocos2d-x will add default shader headers, it will contains buildin uniforms and vertexAttributes. It is better to take a look at it, if the build in uniforms and vertexAttributes is enough, it can be used directly, or new uniforms and vertexAttributes can be added.

`GLProgram` could be used directly for openGL rendering, the step of using `GLProgram` is:

```
//ues glprogram
glprogram->use();
//set build in uniforms
glprogram->setUniformsForBuiltins(...);
//set custom uniforms
glprogram->setUniformLocationXXXXX(...);
```
**Notes**:Before setting uniforms to glprogram, it must be used, or you will get openGL error. `GLProgramState` will solve this problem, so it is recommanded to be used for shaders in cocos2d-x.
###GLProgramState
`GLProgramState` is a high level class for openGL shaders. `GLProgram`, `Uniforms` and `Vertex Attributes` are encapsulated as a reference. There are three functions to create a `GLProgramState`:

```
static GLProgramState* create(GLProgram* glprogram);
static GLProgramState* getOrCreateWithGLProgram(GLProgram* glprogram);
static GLProgramState* getOrCreateWithGLProgramName(const std::string &glProgramName );
```
The first one is simple, a `GLprogramState` could be created from a `GLProgram`.

The second one will take use of `GLProgramStateCache`, which will hold `GLProgramState`, and share it.

The third one is the same as the second, except a string key is used to identify the shader using in cocos2d-x.

After `GLProgramState` is created, table for `Uniforms` and `Vertex Attributes` is generated automatically. Now we can set `Uniform` and `Attributes`:
####Set vertex attributes

```
void setVertexAttribPointer(const std::string &name, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLvoid *pointer);
```
This interface is similar as raw openGL `glVertexAttribPointer` function, except that we can use a string identifier in the shader to locate vertex attribute directly. Another way to set vertex attribute is to use a callback, here is the prototype:

```
void setVertexAttribCallback(const std::string &name, const std::function<void(VertexAttrib*)> &callback);
```
**Notes**: Build in attributes does not need to be set.
####Set uniforms
A series of functions is created to set various type of uniform to GLProgramState.

```
void setUniformInt(const std::string &uniformName, int value);
void setUniformFloat(const std::string &uniformName, float value);
void setUniformVec2(const std::string &uniformName, const Vec2& value);
...
```
These functions are used to set int, float, vec2/3/4 to GLProgramState. Setting textures to openGL shader is complex, one must specify the texture unit, set the texture unit number to shader, and set textureID to correspondent texture unit. In `GLProgramState`, all you need to do is to setting the textureID to the string ID in the shader source, the house keeping work is done automatically.

```
void setUniformTexture(const std::string &uniformName, GLuint textureId);
```
In some rare situations, you may want to call openGL functions to set uniforms, callback could be used to fulfill this.

```
void setUniformCallback(const std::string &uniformName, const std::function<void(GLProgram*, Uniform*)> &callback);
```
**Notes**: Build in uniforms does not need to be set.
####Using GLProgramstate in rendering pipeline
After all the uniforms and vertex attributes is set, now GLProgram is ready to be used for rendering by calling `Node::setGLProgramState(...)`. 

###Examples for using Custom OpenGL Shaders
There are good examples in `CppTest->Shader:Basic` for custom OpenGL shaders, several shaders are used to create a `GLProgram` and `GLProgramState`, then it is set to a sprite to get blur or outline effect. Let's take SpriteBlur as example.

* Shader source: build in shader source `ccPositionTextureColor_noMVP_vert` is used for vertex shader, and fragment shader source is in file `Shaders/example_Blur.fsh`.

* create a `GLProgram`: 
	
	```
	auto program = GLProgram::createWithByteArrays(ccPositionTextureColor_noMVP_vert, fragSource);
	```
* create `GLProgramState`:
	
	```
	auto glProgramState = GLProgramState::getOrCreateWithGLProgram(program);
	```
* set `GLProgramState` to sprite
	
	```
	setGLProgramState(glProgramState);
	```
* set `Uniforms` and `Attributes`
	
	```
	auto size = getTexture()->getContentSizeInPixels();
    getGLProgramState()->setUniformVec2("resolution", size);
    getGLProgramState()->setUniformFloat("blurRadius", _blurRadius);
    getGLProgramState()->setUniformFloat("sampleNum", 7.0f);
	```
    
## c++11 usage
    
## rendering pipeline (notes about this in the wiki)
Since cocos2d-x 3.0, a new `renderer` was used for rendering. Instead of calling openGL function directly, now rendering function calls are encapasulated into renderCommand. RenderCommand is generated when traversing scene, and consumed by `Renderer` to do actual rendering.

The new rendering workflow could be simplied as:

```
void Director::DrawScene()
{
	//visit scene and generate rendering Command
	_runningScene->visit();
	//execute render command and draw
	_render->render();
}
```
The `visit()` function is used to generate render command and traverse the scene.

```
void Node::visit(...)
{
	//visit children zorder less than 0
	for(auto child : childen)
	{
		if(child->_zorder < 0)
			child->visit(...);
	}
	//draw self, generate rendering command and insert it into render
	draw(...)
	//visit children zorder bigger than 0
	for(auto child : childen)
	{
		if(child->_zorder > 0)
			child->visit(...);
	}
}
```
###Different type of RenderCommand
Inorde to support different type of rendering, there are several type of renderCommand. Which is used for specific type of rendering.

####TrianglesCommand and QuadCommand
TrianglesCommand and QuadCommand are two of the mostly used renderCommand. They are used for rendering Triangles and Quads. We will take sprite rendering as an example for showing the usage of these two type of commands.

To render sprite using QuadCommand, what you need to do is:

```
_quadCommand.init(_globalZOrder, textureID, glprogramState, blendFunc, &_quad, quadCount, modelviewTransform);
renderer->addCommand(&_quadCommand);
```
Or you can render sprite with TrianglesCommand

```
//generate two triangles based on quad
static GLushort indices[6] = {0,1,2,3,2,1};
auto triangles = TrianglesCommand::Triangles{&_quad.tl,indices,4,6};
trianglesCommand.(_globalZOrder, textureID, glprogramState, blendFunc, &triangles, modelviewTransform);
renderer->addCommand(&trianglesCommand);
```
When using `TrianglesCommand` and `QuadCommand`, we need to take care about of rendered data. The rendered quads or triangles are pointer in command, so if commands are generated and add to renderer, it is unsafe to delete the sprite.

####GroupCommand

RenderCommands could be sorted by _globalZOrder, command with smaller _globalZorder will be sorted to the front. However, in some situations, we want to the rendering commands to be sorted in a contrained range. 
GroupCommand is designed for this purposem, it includes two features:

* Constrain the command sorting in a range.
* Package all the constrained command into a groupCommand and sort it as a whole.

Examples to use GroupCommand:

```
//package groupCommand
groupCommand.init(_globalZOrder);
renderer->addCommand(&groupCommand);
```

```
render->pushGroup(groupCommand.getRenderQueueID());
//insert other renderCommands here.
//render->addCommand(...);

render->popGroup();
```

The first section is very simple, a groupCommand is created and insert into renderer. And the second one, two functions `pushGroup()` and `popGroup()` is used, renderCommand inserted into renderer between this functions will not be sorted outside of it.

####PrimitiveCommand
PrimitiveCommand was used to send different type of render primitives (such as Points, Lines and Triangles) to renderer. The command will behaves similar as `TrianglesCommand` and `QuadCommand`, but take a `Primitive` as its parameter.

`Primitive` is the most important part of `PrimitiveCommand`.
A Primitive will contains

* `VertexData`: how the vertex data is specified
* `PrimtiveType`: Points, Lines, Triangles
* `IndexBuffer`: optional
* `Start` and `Count`: specify a part of data to be drawn

The process of generate a primitive:

* generate VertexData and vertexBuffer:
	
	```
	auto buff = VertexBuffer::create(vertexSize, vertexCount);
	buff->updateVertices(data, start, count);
	auto vdata = VertexData::create();
	//buff may contains several stream attribute
	vdata->setStream(buff, VertexStreamAttribute(...));
	vdata->setStream(buff, VertexStreamAttribute(...));
	vdata->setStream(buff, VertexStreamAttribute(...));
	```
* generate IndexBuffer if it exsists:
	
	```
	//type could be short16 or int32
	auto iBuff = IndexBuffer::create(type, count);
	iBuff->updateIndices(data, start, count);
	```
* create `Primitive`, specify `PrimtiveType`,`Start` and `Count`
	
	```
	//specify index buffer with null if no index is needed.
	auto primitive = Primitive::create(vdata, iBuff, primitiveType);
	primitive->setStart(...);
	primitive->setCount(...);
	```

####CustomCommand
Just sending points, lines and triangles to openGL is not enough. Some other openGL function must be called to achieve special effects, such as enable or disable depth test, switch a glprogram, set a uniform to shader etc. `CustomCommand` is now used to solve this.
CustomCommand could be used like this:

```
customCommand.init(_globalZOrder);
customCommand.func = CC_CALLBACK0(...);
renderer->addCommand(&customCommand);
```

CustomCommand use callback, which will be called duing `renderer->render()`. So in order to migrate to CustomCommand from cocos2d-x 2.x version. What you need to do is to move the openGL function call into a callback, and using `CC_CALLBACK0` to bind callback to `func` member variable of `CustomCommand`.
One thing to take care is that callback is also a reference, it is not safe to delete the data before the `CustomCommand` is executed by renderer.

## Networking with HTTP

HTTP networking has three steps
   1. Create an `HttpRequest` 
   2. Create a `setResponseCallback()` callback function for replying to requests.
   3. Send `HttpRequest` by `HttpClient` 